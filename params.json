{"name":"Spexs","tagline":"an exhaustive sequence pattern search tool","body":"### Quick introduction\r\n\r\nWhat's **spexs**? It's easier to show what it actually does. To start you need a set of sequences - it can be a sequence of letters or words. For let's imagine we have a data set of events some of them lead to errors and some of them ended normally:\r\n\r\n```\r\n# without errors\r\nAIBBFCACCADAHABXCHCG\r\nGBACDBHBDAIBHYDIHAAADAFAHFGGDBFFYFZBFBAGDIDDX\r\nCAGZHGBAXHFIGBAFBIABDYBABBFDBAFGGAAAAHHC\r\nCGDCHHAAAABFBDBCHBBFGICDBGGDGCDFIFADCA\r\n... snip ...\r\n# with errors\r\nADDDBBCYDFCCHXFDDXBAYDYBHACAZE\r\nDXFDIHBXYDBFGGCBHAYBDHZE\r\nIXBBXHBBACYCFHADHGFDACDHCGYABYBHADZE\r\nAHAFFFGABIXBCAYCBBHBDCDDXZE\r\n... snip ...\r\n```\r\n\r\nThe events `A`, `B`, `C`, `D`, `F`, `G`, `H`, `I`, `X`, `Y`, `Z` are normal events and `E` is the problematic \"error\" event. So we need to figure out which event pattern causes the problem?\r\n\r\nAfter we prepare the configuration file (explained later) and plug in the data **spexs** gives the result:\r\n\r\n```\r\npattern      errors     all         ratio   p-value\r\n... snip ...\r\nF.*Y.*Z      272/343    522/5000    7.588   1.639e-174\r\nX.*A.*Z      305/343    811/5000    5.478   1.798e-176\r\nX.*B.*Z      304/343    785/5000    5.641   1.540e-178\r\nD.*Y.*Z      281/343    557/5000    7.347   1.066e-180\r\nC.*Y.*Z      285/343    584/5000    7.107   1.056e-181\r\nB.*Y.*Z      292/343    610/5000    6.971   2.370e-187\r\nA.*Y.*Z      300/343    616/5000    7.092   3.163e-198\r\nX.*Z         343/343    1054/5000   4.740   1.276e-215\r\nY.*Z         343/343    805/5000    6.204   1.009e-249\r\nX.*Y.*Z      343/343    343/5000    14.537  0\r\n```\r\n\r\nWhich means that we found an interesting pattern `X.*Y.*Z` (using the regular expression notation).\r\n\r\nRemember that **spexs** isn't a magical tool that knows which kinds of patterns you are looking for, so you need to configure the tool appropriately.\r\n\r\n### Overview\r\n\r\nThe easiest way to get started is to download an example that is most similar with your problem. Then adjust the configuration and finally tweak until it fits.\r\n\r\nThe simplest approach to running the tool is:\r\n\r\n```\r\n./spexs2 -conf=conf.json inp=data.txt ref=random.txt\r\n```\r\n\r\nWe need to give it a configuration file to specify how to find patterns. Let's examine the configuration file:\r\n\r\n```\r\n{\r\n    \"Dataset\": {\r\n        \"fore\" : { \"File\" : \"$inp$\" },\r\n        \"back\" : { \"File\" : \"$ref$\" }\r\n    },\r\n    \"Reader\" : {\r\n        \"Method\" : \"Delimited\",\r\n        \"Separator\" : \"\",\r\n        \"CountSeparator\": \"\"\r\n    },\r\n    \"Extension\": {\r\n        \"Method\": \"Star\",\r\n        \"Groups\" : {\r\n            \".\" : { \"elements\" : \"ABCDFGHIXYZ\"}\r\n        },\r\n        \"Extendable\": {\r\n            \"PatLength()\" : {\"max\" : 7},\r\n            \"PatGroups()\" : {\"max\" : 3},\r\n            \"Matches(fore)\" : {\"min\" : 250},\r\n            \"NoStartingGroup()\" : {},\r\n            \"NoTokens()\" : {\"Tokens\":\"E\"},\r\n        },\r\n        \"Outputtable\" : {\r\n            \"PatLength()\" : {\"min\" : 3},\r\n            \"Hyper(fore, back)\" : {\"max\" : $limit:1e-10$},\r\n            \"NoEndingGroup()\" : {}\r\n        }\r\n    },\r\n    \"Output\": {\r\n        \"SortBy\": [\"-Hyper(fore,back)\", \"Matches(fore)\"],\r\n        \"Count\": 20\r\n    },\r\n    \"Printer\" : {\r\n        \"Method\" : \"Formatted\",\r\n        \"ShowHeader\": true,\r\n        \"Reverse\": true,\r\n        \"Header\": \"\",\r\n        \"Format\": \"Pat?()\\tMatchesPropRatio(fore,back)\\tHyper(fore,back)\\n\"\r\n    }\r\n}\r\n```\r\n\r\nFirst the configuration looks a lot like *json* format, but it can also deal with small user errors, like missing trailing commas. As we can see the configuration is divided into 5 parts: Dataset, Reader, Extension, Output and Printer. Each specifies a particular part of the tool.\r\n\r\n#### Dataset\r\n\r\nThe datasets define where we get our input sequences. There are several ways to specify which files to load:\r\n\r\n```\r\n\"Dataset\": {\r\n    \"single\" : { \"File\" : \"data\" },\r\n    \"multiple\" : { \"Files\" : [\"a.txt\", \"b.txt\", \"c.txt\"]},\r\n    \"filelist\" : { \"Filelist\" : \"listing.txt\" },\r\n    \"cmdline\" : {\"File\" : \"$inp$\"}\r\n},\r\n```\r\n\r\nThe key values in the definition are names for the datasets. These names will be used in the configuration file later.\r\n\r\nThe *single* just loads the sequences in the file \"data\". The *multiple* and *filelist* loads sequences from multiple files.\r\n\r\nThe *cmdline* dataset uses special syntax that is used to mix configuration file and command line parameters. If we run the tool with arguments:\r\n\r\n```\r\n./spexs2 -conf=conf.json inp=data.txt\r\n```\r\n\r\nThen the `$inp$` in the configuration file will be replaced with `data.txt`. You can also provide default values, for cases where the parameter is missing. For example, if we use `$inp:data$` in the configuration and the `inp` parameter isn't specified it will be replaced with `data` in the configuration file.\r\n\r\n#### Reader\r\n\r\nReader specifies how to read in the input. \"Method\" specifies how to read in the sequences and the rest are arguments to the reader. There are currently to ways of reading the input: \"Delimited\" and \"Counted\".\r\n\r\n```\r\n\"Reader\" : {\r\n    \"Method\" : \"Delimited\",\r\n    \"Separator\" : \"\",\r\n    \"Skip\": \"_,.-'\",\r\n},\r\n```\r\n\r\n\"Separator\" specifies how to split the sequences into separate tokens. For example using separator \"\" will break \"AB C\" into \"A\", \"B\", \" \", \"C\" and using separator \" \" will break \"AB C\" into \"AB\", \"C\". This separator gives the ability to use letters or letter sequences as our token in the patterns.\r\n\r\n\"Skip\" allows to ignore tokens that are in the input sequence. The \"Skip\" will be split into tokens in the same way as the sequences, using the \"Separator\".\r\n\r\nThere is an alternative way for reading the input:\r\n\r\n```\r\n\"Reader\" : {\r\n    \"Method\" : \"Counted\",\r\n    \"Separator\" : \"\",\r\n    \"CountSeparator\" : \":\"\r\n},\r\n```\r\n\r\nThis counted reader expects the input to be in the format:\r\n\r\n```\r\nnumber CountSeparator sequence\r\n```\r\n\r\nFor example:\r\n\r\n```\r\n5:ABCDEFGH\r\n2:CBBDAGHE\r\n1:ABCDAD\r\n```\r\n\r\nIf we know how many times a sequence occured we can use this to provide a weight for the patterns.\r\n\r\n#### Extension\r\n\r\nExtension part specifies which patterns will be searched and are nice enough for output.\r\n\r\n```\r\n\"Extension\": {\r\n    \"Method\": \"Star\",\r\n    \"Groups\" : {\r\n        \"g1\" : { \"elements\" : \"ABC\"},\r\n        \"g2\" : { \"elements\" : \"CDE\"},\r\n    },\r\n    \"Extendable\": {\r\n        \"PatLength()\" : {\"max\" : 7},\r\n        \"PatGroups()\" : {\"max\" : 3},\r\n        \"Matches(fore)\" : {\"min\" : 250},\r\n        \"NoStartingGroup()\" : {},\r\n        \"NoTokens()\" : {\"Tokens\":\"E\"},\r\n    },\r\n    \"Outputtable\" : {\r\n        \"PatLength()\" : {\"min\" : 3},\r\n        \"Hyper(fore, back)\" : {\"max\" : $limit:1e-10$},\r\n        \"NoEndingGroup()\" : {}\r\n    }\r\n},\r\n```\r\n\r\nThe \"Method\" specifies which kinds of patterns it will search. Currently there are 4 different ways for finding patterns: Simple, Group, Star, Regex. \r\n\r\n##### Methods\r\n\r\nThe \"Simple\" method will find only patterns that are a simple sequence of tokens.\r\n\r\nThe \"Group\" method will find patterns that can contain groups specified in the \"Groups\" parameter. The group means an alternate possibility for a token. For example, in regular expression syntax it can find patterns `A[BC]D`. The \"Groups\" allows to specify which groups will be searched for.\r\n\r\nThe \"Star\" method will find patterns that can contain gaps in the pattern. For example, in regular expression it would look like `A.*D`.\r\n\r\nThe \"Regex\" method will find patterns that can contain either groups or gaps. For example, it could look like `A.*[BC]`.\r\n\r\n##### Features\r\n\r\nFeatures are the properties of the patterns. For example, how many times the pattern occurs in a dataset, or how long it is, or the probablity of finding such pattern.\r\n\r\nFeatures allow to define filters (explained in the next section) and they can be used for printing the result. To specify a feature we use the name of the filter and use data set names as argument. For example, to find the number of matching sequences in the data set \"alpha\" we can specify `Matches(alpha)`.\r\n\r\nThe full list of features can be seen on the command line with `./spexs2 --details`.\r\n\r\nThere are important features \"Binom\" and \"Hyper\" that allow us to find interesting patterns. To determine whether a pattern happens by chance or is, indeed, characteristic to the data we need to use some statistics. We can calculate how probable some pattern is when we compare the number of matches in the data to the number of matches in some random data. If a pattern is found in the input and random data the same number of times, it probably occured by chance. If a pattern is only found in the input data, then it probably is very interesting.\r\n\r\n##### Filters\r\n\r\nThe filters specify how to limit our search space - or more trivially, how to skip looking at the patterns.\r\n\r\nThe \"Extendable\" filter specifies our search space, for example here we can add a limit to the pattern length or skip patterns with low number of occurences.\r\n\r\nThe \"Outputtable\" filter specifies the patterns that we allow to be printed. For example we probably do not want very small patterns.\r\n\r\nThe feature filter defintion looks like:\r\n\r\n```\r\n\"Feature(dataset)\" : { \"min\" : 0, \"max\" : $max:13$ }\r\n```\r\n\r\nWe can use the special syntax to specify limits from the command-line as well.\r\n\r\n#### Output\r\n\r\nWe can use output to specify how many of the \"best\" patterns will be remembered and how they will be sorted:\r\n\r\n```\r\n\"Output\": {\r\n    \"SortBy\": [\"-Hyper(fore,back)\", \"Matches(fore)\"],\r\n    \"Count\": 20\r\n},\r\n```\r\n\r\n\"SortBy\" defines how to decide which are the top results. It takes an array of features as the sorting, if the first feature value is same for two patterns it will use the second etc.\r\n\r\n\"Count\" simply specifies the how many top results to keep.\r\n\r\n#### Printer\r\n\r\nPrinter specifies how to show the results in the command line:\r\n\r\n```\r\n\"Printer\" : {\r\n    \"ShowHeader\": true,\r\n    \"Reverse\": true,\r\n    \"Header\": \"\",\r\n    \"Format\": \"Pat?()\\tMatchesPropRatio(fore,back)\\tHyper(fore,back)\\n\"\r\n}\r\n```\r\n\r\n\"ShowHeader\" specifies whether to add an header to the output. \"Reverse\" allows to reverse the ordering of the output patterns, this is especially useful when testing the tool, since the best results will be printed to the console last.\r\n\r\n\"Header\" is an optional argument for giving nice looking column headers. If the value is empty the \"Format\" string will be used instead.\r\n\r\n\"Format\" is how we want to print the feature values to the output.\r\n\r\n\r\n### Tips\r\n\r\nTo get started find an example configuration file from the examples that is most similar to your problem.\r\n\r\nIf you want to use it for large datasets, first try running it on a smaller sample to see whether the limits work nicely.\r\n\r\nIf the process takes too long try putting in more \"Extendable\" filters or adding more limits. If the tool doesn't find any results try removing some \"Extendable\" and/or \"Outputtable\" filters.\r\n\r\n### License\r\n\r\n```\r\nspexs2\r\nCopyright (C) 2012  University of Tartu\r\n\r\nThis program is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nThis program is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU General Public License for more details.\r\n\r\nYou should have received a copy of the GNU General Public License\r\nalong with this program. If not, see <http://www.gnu.org/licenses/>.\r\n```","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}